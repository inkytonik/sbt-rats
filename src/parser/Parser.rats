/*
 * This file is part of the sbt-rats plugin.
 * Copyright (c) 2012 Anthony M Sloane, Macquarie University.
 * All rights reserved.
 * Distributed under the New BSD license.
 * See file LICENSE at top of distribution.
 */

module parser.Parser;

header {
    import ast.*;
    import ast.SList.*;
    import org.kiama.output.LeftAssoc$;
    import org.kiama.output.NonAssoc$;
    import org.kiama.output.RightAssoc$;
    import scala.collection.immutable.List;
    import scala.collection.immutable.Nil$;
    import scala.collection.immutable.$colon$colon;
    import scala.util.parsing.input.Positional;
    import scala.util.parsing.input.Position;
    import xtc.util.Action;
}

body {
    static {
        add (KEYWORDS, new String[] {
            "comment", "header", "left", "line", "module", "nest", "none",
            "paren", "rats", "right", "sp", "String"
        });
    }

    /** Set position of a Positional */
    void setLocation(final Positional positional, final int index) {
        if (null != positional) {
            Column c = column(index);
            positional.setPos(new LineColPosition(c.line, c.column));
        }
    }
}

option setOfString (KEYWORDS), withLocation;

public Grammar Grammar =
    p:PackageDecl h:HeaderSection? rs:Rule* EOF {
        yyValue = new Grammar (p, h, rs);
    };

// Package declarations

Pair<String> PackageDecl =
    void:"module":Word QualIdentifier void:";":Symbol;

// Header section

String HeaderSection =
    void:"header":Word CodeBlock;

String CodeBlock =
    '{' yyValue:CodeBlockText '}' Spacing;

transient String CodeBlockText =
    ('{' CodeBlockText '}' / !'}' _)*;

// Rules

Rule Rule =
      GrammarRule void:".":Symbol
    / RatsSection;

// Grammar rules

Rule GrammarRule =
    i:IdnDef StringType void:"=":Symbol alts:StringAlternatives {
        yyValue = new StringRule (i, alts);
    } /
    i:IdnDef t:Type? anns:Annotations? void:"=":Symbol alts:ASTAlternatives {
        yyValue = new ASTRule (i, t, alts, false, anns);
    };

// Types

transient void StringType =
    void:":":Symbol void:"String":Word;

IdnUse Type =
    void:":":Symbol IdnUse;

// Alternatives

Pair<Element> StringAlternatives =
    h:Element tl:(void:"|":Symbol Element)* {
        yyValue = SList.create (h, tl);
    };

Pair<Alternative> ASTAlternatives =
    h:ASTAlternative tl:(void:"|":Symbol ASTAlternative)* {
        yyValue = SList.create (h, tl);
    };

Alternative ASTAlternative =
    es:ASTElement+ as:Annotations? {
        yyValue = new Alternative (es, as, new DefaultAction ());
    };

// Elements

Element Element =
    seed:Element1 actions:AltTail+ {
        yyValue = apply (actions, seed);
    } /
    Element1;

constant Action<Element> AltTail =
    void:"/":Symbol right:Element {
        yyValue = new Action<Element> () {
            public Element run (Element left) {
                return new Alt (left, right);
            }
        };
    };

Element Element1 =
    seed:Element2 actions:SeqnTail+ {
        yyValue = apply (actions, seed);
    } /
    Element2;

constant Action<Element> SeqnTail =
    right:Element2 {
        yyValue = new Action<Element> () {
            public Element run (Element left) {
                return new Seqn (left, right);
            }
        };
    };

Element Element2 =
    e:Primary void:"*":Symbol {
        yyValue = new Rep (true, e);
    } /
    e:Primary void:"+":Symbol {
        yyValue = new Rep (false, e);
    } /
    e:Primary void:"?":Symbol {
        yyValue = new Opt (e);
    } /
    Primary;

Element Primary =
    void:"(":Symbol Element void:")":Symbol /
    void:"!":Symbol p:Primary {
        yyValue = new Not (p);
    } /
    Literal Spacing /
    i:IdnUse {
        yyValue = new NonTerminal (i);
    };

// AST elements

Element ASTElement =
    Formatting /
    ASTFactor;

Element ASTFactor =
    e:ASTPrimary void:"*":Symbol {
        yyValue = new Rep (true, e);
    } /
    e:ASTPrimary void:"+":Symbol {
        yyValue = new Rep (false, e);
    } /
    e:ASTPrimary void:"?":Symbol {
        yyValue = new Opt (e);
    } /
    Literal Spacing /
    ASTPrimary;

Element ASTPrimary =
    i:IdnUse {
        yyValue = new NonTerminal (i);
    };

// Formatting

Element Formatting =
    void:"\\n":Symbol {
        yyValue = new Newline ();
      }
    / void:"nest":Word void:"(":Symbol e:ASTFactor void:")":Symbol {
        yyValue = new Nest (e);
    }
    / void:"sp":Word {
        yyValue = new Space ();
    };

// Annotations

Pair<Annotation> Annotations =
    void:"{":Symbol AnnotationList void:"}":Symbol;

Pair<Annotation> AnnotationList =
    h:Annotation tl:(void:",":Symbol Annotation)* {
        yyValue = SList.create (h, tl);
    };

Annotation Annotation =
    Associativity /
    Formatter /
    Constructor /
    Transformation /
    Precedence;

Annotation Associativity =
    void:"left":Word {
        yyValue = new Associativity (LeftAssoc$.MODULE$);
    } /
    void:"none":Word {
        yyValue = new Associativity (NonAssoc$.MODULE$);
    } /
    void:"right":Word {
        yyValue = new Associativity (RightAssoc$.MODULE$);
    };

Annotation Constructor =
    i:Identifier {
        yyValue = new Constructor (i);
    };

Annotation Formatter =
    void:"line":Word {
        yyValue = new Line ();
    } /
    void:"paren":Word {
        yyValue = new Parenthesized ();
    };

Annotation Transformation =
    d:DecDigits void:":":Symbol m:QualIdentifier void:":":Symbol t:QualIdentifier {
        yyValue = new Transformation (Integer.parseInt (d), m, t);
    };

Annotation Precedence =    
    d:DecDigits {
        yyValue = new Precedence (Integer.parseInt (d));
    };

String DecDigits =
    [0-9]+;

// Rats! code section

RatsSection RatsSection =
    void:"rats":Word s:CodeBlock {
        yyValue = new RatsSection (s);
    };

// Identifiers

IdnUse IdnUse =
    i:Identifier {
        yyValue = new IdnUse (i);
    };

IdnDef IdnDef =
    i:Identifier {
        yyValue = new IdnDef (i);
    };

Pair<String> QualIdentifier =
    h:Identifier tl:(void:".":Symbol Identifier)* {
        yyValue = SList.create (h, tl);
    };

String Identifier =
    yyValue:Word &{
        ! contains (KEYWORDS, yyValue)
    };

// Literals

Element Literal =
    '_' {
        yyValue = new Wildcard ();
    } /
    ["] s:StringLiteral ["] {
        yyValue = new StringLit (s);
    } /
    ['] s:CharLiteral ['] {
        yyValue = new CharLit (s);
    } / 
    '[' s:CharClassContents ']' {
        yyValue = new CharClass (s);
    };

String StringLiteral =
    (Escape / !["] _)*;

String CharLiteral =
    (Escape / !['] _)*;

String CharClassContents =
    CharClassElement*;

String CharClassElement =
    CharClassCharacter '-' CharClassCharacter /
    CharClassCharacter;

String CharClassCharacter =
    Escape /
    ![\-\]\\] _;

String Escape =
    '\\' [btnfr"'\[\\\]\-] /
    '\\' 'u' HexQuad /
    OctalEscape;

String HexQuad =
    HexDigit HexDigit HexDigit HexDigit;

String HexDigit =
    [0-9a-fA-F];

String OctalEscape =
    '\\' ([0-3] OctDigit OctDigit / OctDigit OctDigit / OctDigit);

String OctDigit =
    [0-7];

String DecDigit =    
    [0-9];

// Words

String Word =
    WordCharacters Spacing;

transient String WordCharacters =
    h:_ &{
        Character.isJavaIdentifierStart (h)
    } (t:_ &{
        Character.isJavaIdentifierPart (t)
    })*;

// Syntax symbols

String Symbol =
    SymbolCharacters Spacing;

transient String SymbolCharacters =
    ":" / "=" / "/" / "|" / "{" / "}" / "(" / ")" / "!" / "." / "," /
    "*" / "+" / "?" / ";" / "\\n";

transient void Spacing   = (Space / SLComment / MLComment)*;
transient void FSpacing  = (Space / SLComment / MLComment)+;
transient void Space     = ' ' / '\t' / '\f' / EOL;
transient void SLComment = "//" (![\n\r] _)* EOL;
transient void MLComment = "/*" (MLComment / !"*/" _)* "*/";
transient void EOL       = '\r' '\n' / '\r' / '\n';
transient void EOF       = !_;    

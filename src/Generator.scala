import org.kiama.output.PrettyPrinter

object Generator extends PrettyPrinter {

    import ast._
    import sbt.File
    import sbt.IO.write

    /**
     * Generate a Scala case class implmentation of the abstract syntax 
     * used by the grammar.
     */
    def generateASTClasses (flags : Flags, astFile : File, grammar : Grammar) {

        import Analyser.elemtype
        import org.kiama.attribution.Attribution.initTree
        import org.kiama.rewriting.Rewriter.{alltd, rewrite, query}
        import scala.collection.mutable.ListBuffer

        def toAST : Doc =
            "// AUTOMATICALLY GENERATED by sbt-rats - EDIT AT YOUR OWN RISK" <@>
            line <>
            "package" <+> grammar.pkg.init.mkString (".") <@>
            toImports <>
            toSyntax <>
            line

        def toSyntax : Doc =
            line <>
            "object Syntax {" <@>
            nest (
                toSuperClass <@>
                hsep (grammar.rules map toRuleClasses)
            ) <@>
            "}"

        def includeImportWhen (importEntity : String, cond : Boolean) : Doc =
            if (cond)
                "import" <+> importEntity <> line
            else
                empty

        def toImports : Doc =
            line <>
            includeImportWhen ("scala.util.parsing.input.Positional",
                               flags.useScalaPositions) <>
            includeImportWhen ("org.kiama.attribution.Attributable",
                               flags.useKiama)

        def toSuperClass : Doc = {
            val superTraits = List (
                if (flags.useScalaPositions) List ("Positional") else Nil,
                if (flags.useKiama) List ("Attributable") else Nil
            ).flatten

            line <>
            "abstract class ASTNode extends" <+> hsep (superTraits map text, " with")
        }

        def toRuleClasses (rule : Rule) : Doc =
            rule match {
                case r : ASTRule => toASTRuleClasses (r)
                case _           => empty
            }

        def toASTRuleClasses (astRule : ASTRule) : Doc = {

            val ASTRule (lhs, tipe, alts, _) = astRule

            // Alternatives that have something to say about the tree
            val treeAlts = alts.filter (alt => (alt.anns != null) && (alt.anns.length > 0))

            def toFields (alt : Alternative) : Doc = {

                /**
                 * Map of field number to type as given by the alternative's
                 * annotations.
                 */
                val fieldTypes : Map[Int,String] =
                    if (alt.anns == null)
                        Map.empty
                    else
                        alt.anns.collect {
                            case Transformation (n, _, t) =>
                                (n, t.mkString ("."))
                        }.reverse.toMap

                /**
                 * Representation of a field by its name and its type.
                 */
                case class Field (name : String, tipe : String)

                /**
                 * List of fields in the process of being built.
                 */
                val fields = ListBuffer[Field] ()

                /**
                 * List of Scala keywords used to avoid declaring a field whose name
                 * is a keyword.
                 */
                val scalaKeywords = List (
                    "abstract", "case", "catch", "class", "def", "do", "else",
                    "extends", "false", "final", "finally", "for", "forSome", "if",
                    "implicit", "import", "lazy", "match", "new", "null", "object",
                    "override", "package", "private", "protected", "return", "sealed",
                    "super", "this", "throw", "trait", "true", "try", "type", "val",
                    "var", "while", "with", "yield"
                )

                /**
                 * Convert a non-terminal name to a field name, making sure that the 
                 * fields will be unique. Prefix is a string that we want to put on 
                 * the beginning of the field name, suffix should go on the end.
                 */
                def nameToFieldName (prefix : String, name : String, suffix : String) : String = {
                    val fieldName =
                        if (prefix == "")
                            "%s%s".format (name.toLowerCase, suffix)
                        else
                            "%s%s%s%s".format (prefix, name.head.toUpper, name.tail.toLowerCase,
                                               suffix)
                    if (scalaKeywords contains fieldName)
                        "%sField".format (fieldName)
                    else
                        fieldName
                }

                /**
                 * Add a field with the given name and type of the given element.
                 */
                def addField (fieldName : String, elem : Element) {
                    // FIXME: keep counter to avoid having to recompute?
                    val fieldNum = fields.length + 1
                    val fieldType = fieldTypes.getOrElse (fieldNum, elem->elemtype)
                    fields.append (Field (fieldName, fieldType))
                }

                /**
                 * Traverse the elements on the RHS of the rule to collect fields. 
                 */
                def traverseRHS (elem : Element) {
                    elem match {
                        case Seqn (l, r) =>
                            traverseRHS (l)
                            traverseRHS (r)
                        case NonTerminal (IdnUse (name)) =>
                            addField (nameToFieldName ("", name, ""), elem)
                        case Opt (NonTerminal (IdnUse (name))) =>
                            addField (nameToFieldName ("opt", name, ""), elem)
                        case Rep (zero, NonTerminal (IdnUse (name))) =>
                            addField (nameToFieldName (if (zero) "opt" else "", name, "s"), elem)
                        case _ =>
                            // No argument for the rest of the element kinds
                    }
                }

                // Traverse the RHS elememts to collect field information
                traverseRHS (alt.rhs)

                // Set of non-unique field names
                val nonUniqueFieldNames =
                    fields.map (_.name).groupBy (s => s).collect {
                        case (n, l) if l.length > 1 =>
                            n
                    }.toSet

                /**
                 * Is the field name not unique in this field list?
                 */
                def isNotUnique (fieldName : String) : Boolean =
                    nonUniqueFieldNames contains fieldName

                /**
                 * Make the field names unique by numbering fields whose names are 
                 * not unique.
                 */
                val uniqueFields =
                    fields.result.foldLeft (Map[String,Int] (), List[Field] ()) {
                        case ((m, l), f @ Field (n, t)) =>
                            if (isNotUnique (n)) {
                                val i = m.getOrElse (n, 0) + 1
                                (m.updated (n, i), Field (n + i.toString, t) :: l)
                            } else
                                (m, f :: l)
                    }

                /**
                 * Convert the final field list to a list of documents.
                 */
                val fieldDocs =
                    uniqueFields._2.reverse map {
                        case Field (n, t) => n <+> colon <+> t
                    }

                // Assemble final document for argument list
                parens (hsep (fieldDocs, comma))

            }

            def toConcreteClass (parent : String) (alt : Alternative) : Doc =
                alt.anns.collect {
                    case Constructor (name) =>
                        name
                } match {
                    case name :: _ => 
                        "case class" <+> name <+> toFields (alt) <+> "extends" <+> parent
                    case _         =>
                        empty
                }

            // Common super class clause
            val superClass = "extends" <+> "ASTNode"

            line <>
            (if (tipe == null)
                if (alts.length == 1)
                    "case class" <+> lhs.name <+> toFields (alts.head) <+> superClass
                else
                    "abstract class" <+> lhs.name <+> superClass <@>
                    vsep (treeAlts map (toConcreteClass (lhs.name)))
             else
                vsep (treeAlts map (toConcreteClass (tipe.name)))) <>
            line

        }

        // Initialise the tree so we can perform attribution on it
        initTree (grammar)

        // Put together top level code
        val code = pretty (toAST)

        // Put the code in the specified file
        write (astFile, code)

    }

    /**
     * Generate module of supporting code for Scala-based parsers.
     */
    def generateSupportFile (flags : Flags, supportFile : File) {
    
        val contents = """
            |// AUTOMATICALLY GENERATED by sbt-rats - EDIT AT YOUR OWN RISK
            |
            |package sbtrats
            |
            |trait Action[T] {
            |    def run (arg : T) : T
            |}
            |
            |object ParserSupport {
            |
            |    def apply[T] (actions : List[Action[T]], seed : T) : T = {
            |        var result = seed
            |        for (action <- actions) {
            |            result = action.run (result)
            |        }
            |        result
            |    }
            |
            |}
            |""".stripMargin

        write (supportFile, contents)

        if (flags.useScalaPositions) {

            val lineColContents =
                """
                |import scala.util.parsing.input.{Position, Positional}
                |
                |class LineColPosition (val line : Int, val column : Int) extends Position {
                |
                |    override def < (that : Position) : Boolean =
                |        line < that.line || 
                |            line == that.line && column < that.column
                |
                |    override def lineContents : String =
                |        throw new RuntimeException ("LineColPosition.lineContents not implemented")
                |
                |    override def longString : String =
                |        throw new RuntimeException ("LineColPosition.longString not implemented")
                |
                |    override def toString () : String =
                |        "" + line + "." + column
                |
                |}
                |""".stripMargin

            write (supportFile, lineColContents, append = true)

        }

    }

}

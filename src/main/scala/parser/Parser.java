// ===========================================================================
// This file has been generated by
// Rats! Parser Generator, version 2.3.1,
// (C) 2004-2012 Robert Grimm,
// on Thursday, 27 September 2018 at 4:43:51 PM.
// Edit at your own risk.
// ===========================================================================

package parser;

import java.io.Reader;
import java.io.IOException;

import java.util.HashSet;
import java.util.Set;

import xtc.util.Pair;


import xtc.parser.ParserBase;
import xtc.parser.Column;
import xtc.parser.Result;
import xtc.parser.SemanticValue;
import xtc.parser.ParseError;

import ast.*;
import ast.SList.*;
import org.kiama.output.LeftAssoc$;
import org.kiama.output.NonAssoc$;
import org.kiama.output.RightAssoc$;
import org.kiama.util.Positions;
import scala.collection.immutable.List$;
import scala.collection.immutable.List;
import scala.collection.immutable.Nil$;
import scala.collection.immutable.$colon$colon;
import xtc.util.Action;

/**
 * Packrat parser for grammar <code>parser.Parser</code>.
 *
 * <p />This class has been generated by the <i>Rats!</i> parser
 * generator, version 2.3.1, (C) 2004-2012 Robert Grimm.
 */
public final class Parser extends ParserBase {

  /** The KEYWORDS set. */
  public static final Set<String> KEYWORDS = new HashSet<String>();

  // =========================================================================

  /** Chunk 1 of memoized results. */
  static final class Chunk1 {
    Result fCodeBlock;
    Result fCodeBlockText;
    Result fOption;
    Result fStringType;
    Result fType;
    Result fTreeAlternative;
    Result fTreeAlternative$$Star1;
    Result fStringElement;
    Result fStringElement$$Plus1;
    Result fStringElement1;
  }

  /** Chunk 2 of memoized results. */
  static final class Chunk2 {
    Result fStringElement1$$Plus1;
    Result fStringElement2;
    Result fPrimary;
    Result fTreeFactor;
    Result fTreePrimary;
    Result fTreeNonterm;
    Result fTreeAtMostOneNonterm;
    Result fTreeNoNonterm;
    Result fTreeLiteral;
    Result fFormatting;
  }

  /** Chunk 3 of memoized results. */
  static final class Chunk3 {
    Result fRuleAnnotation;
    Result fAltAnnotation;
    Result fIdnUse;
    Result fIdnDef;
    Result fQualIdentifier;
    Result fQualIdentifier$$Star1;
    Result fIdentifier;
    Result fLiteral;
    Result fCharClassCharacter;
    Result fEscape;
  }

  /** Chunk 4 of memoized results. */
  static final class Chunk4 {
    Result fDecDigits;
    Result fWord;
    Result fSymbol;
  }

  // =========================================================================

  /** Memoization table column. */
  static final class ParserColumn extends Column {
    Chunk1 chunk1;
    Chunk2 chunk2;
    Chunk3 chunk3;
    Chunk4 chunk4;
  }

  // =========================================================================

  /**
   * Create a new packrat parser.
   *
   * @param reader The reader.
   * @param file The file name.
   */
  public Parser(final Reader reader, final String file) {
    super(reader, file);
  }

  /**
   * Create a new packrat parser.
   *
   * @param reader The file reader.
   * @param file The file name.
   * @param size The file size.
   */
  public Parser(final Reader reader, final String file, final int size) {
    super(reader, file, size);
  }

  // =========================================================================

  protected Column newColumn() {
    return new ParserColumn();
  }

  // =========================================================================

  /**
   * Parse nonterminal parser.Parser.Grammar.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pGrammar(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyRepetition1;
    List<Rule> yyRepValue1;
    int        yyOption1;
    Object     yyOpValue1;
    Grammar    yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSpacing(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pModuleDecl(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        List<String> m = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = null;

        yyResult = pHeaderSection(yyOption1);
        yyError  = yyResult.select(yyError, yyOption1);
        if (yyResult.hasValue()) {
          String v$el$1 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$1;
        }
        { // Start scope for h.
          String h = cast(yyOpValue1);

          yyOpValue1 = null;

          yyResult = pBodySection(yyOption1);
          yyError  = yyResult.select(yyError, yyOption1);
          if (yyResult.hasValue()) {
            String v$el$2 = yyResult.semanticValue();

            yyOption1  = yyResult.index;
            yyOpValue1 = v$el$2;
          }
          { // Start scope for b.
            String b = cast(yyOpValue1);

            yyOpValue1 = null;

            yyResult = pOptions(yyOption1);
            yyError  = yyResult.select(yyError, yyOption1);
            if (yyResult.hasValue()) {
              List<SyntaxOption> v$el$3 = yyResult.semanticValue();

              yyOption1  = yyResult.index;
              yyOpValue1 = v$el$3;
            }
            { // Start scope for o.
              List<SyntaxOption> o = cast(yyOpValue1);

              yyRepetition1 = yyOption1;
              yyRepValue1   = List$.MODULE$.empty();
              while (true) {

                yyResult = pRule(yyRepetition1);
                yyError  = yyResult.select(yyError, yyRepetition1);
                if (yyResult.hasValue()) {
                  Rule v$el$4 = yyResult.semanticValue();

                  yyRepetition1 = yyResult.index;
                  yyRepValue1   = new $colon$colon<Rule>(v$el$4, yyRepValue1);
                  continue;
                }
                break;
              }
              { // Start scope for rs.
                List<Rule> rs = yyRepValue1.reverse();

                yyResult = pEOF(yyRepetition1);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyValue = new Grammar (m, h, b, o, rs);

                  if (yyValue instanceof Object) {
                    setLocation((Object)yyValue, yyStart);
                  }
                  return yyResult.createValue(yyValue, yyError);
                }
              } // End scope for rs.
            } // End scope for o.
          } // End scope for b.
        } // End scope for h.
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal parser.Parser.ModuleDecl.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pModuleDecl(final int yyStart) throws IOException {
    Result       yyResult;
    int          yyBase;
    List<String> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pWord(yyStart);
    if (yyResult.hasValue("module")) {

      yyResult = pQualIdentifier(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        yyValue = yyResult.semanticValue();

        yyBase   = yyResult.index;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue(";")) {

          return yyResult.createValue(yyValue, yyError);
        } else {
          yyError = yyError.select("';' expected", yyBase);
        }
      }
    }

    // Done.
    yyError = yyError.select("module decl expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal parser.Parser.HeaderSection.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pHeaderSection(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pWord(yyStart);
    if (yyResult.hasValue("header")) {

      yyResult = pCodeBlock(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        yyValue = yyResult.semanticValue();

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("header section expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal parser.Parser.BodySection.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pBodySection(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pWord(yyStart);
    if (yyResult.hasValue("body")) {

      yyResult = pCodeBlock(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        yyValue = yyResult.semanticValue();

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("body section expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal parser.Parser.CodeBlock.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCodeBlock(final int yyStart) throws IOException {
    ParserColumn yyColumn = (ParserColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fCodeBlock) 
      yyColumn.chunk1.fCodeBlock = pCodeBlock$1(yyStart);
    return yyColumn.chunk1.fCodeBlock;
  }

  /** Actually parse parser.Parser.CodeBlock. */
  private Result pCodeBlock$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('{' == yyC) {
      yyIndex = yyStart + 1;

      yyResult = pCodeBlockText(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        yyValue = yyResult.semanticValue();

        yyC = character(yyResult.index);
        if ('}' == yyC) {
          yyIndex = yyResult.index + 1;

          yyResult = pSpacing(yyIndex);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            return yyResult.createValue(yyValue, yyError);
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("code block expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal parser.Parser.CodeBlockText.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCodeBlockText(final int yyStart) throws IOException {
    ParserColumn yyColumn = (ParserColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fCodeBlockText) 
      yyColumn.chunk1.fCodeBlockText = pCodeBlockText$1(yyStart);
    return yyColumn.chunk1.fCodeBlockText;
  }

  /** Actually parse parser.Parser.CodeBlockText. */
  private Result pCodeBlockText$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '{':
        {
          yyResult = pCodeBlockText(yyIndex);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyC = character(yyResult.index);
            if ('}' == yyC) {
              yyIndex = yyResult.index + 1;

              yyResult = pCodeBlockText(yyIndex);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyValue = difference(yyStart, yyResult.index);

                return yyResult.createValue(yyValue, yyError);
              }
            }
          }
        }
        break;

      default:
        /* No match. */
      }
    }

    // Alternative 2.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;
      if ('}' != yyC) {

        yyResult = pCodeBlockText(yyIndex);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = difference(yyStart, yyResult.index);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 3.

    yyValue = "";

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal parser.Parser.Options.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pOptions(final int yyStart) throws IOException {
    Result             yyResult;
    int                yyBase;
    int                yyRepetition1;
    List<SyntaxOption> yyRepValue1;
    List<SyntaxOption> yyValue;
    ParseError         yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pWord(yyStart);
    if (yyResult.hasValue("option")) {

      yyResult = pOption(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        SyntaxOption h = yyResult.semanticValue();

        yyRepetition1 = yyResult.index;
        yyRepValue1   = List$.MODULE$.empty();
        while (true) {

          yyBase   = yyRepetition1;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue(",")) {

            yyResult = pOption(yyResult.index);
            yyError  = yyResult.select(yyError, yyRepetition1);
            if (yyResult.hasValue()) {
              SyntaxOption v$el$1 = yyResult.semanticValue();

              yyRepetition1 = yyResult.index;
              yyRepValue1   = new $colon$colon<SyntaxOption>(v$el$1, yyRepValue1);
              continue;
            }
          } else {
            yyError = yyError.select("',' expected", yyBase);
          }
          break;
        }
        { // Start scope for tl.
          List<SyntaxOption> tl = yyRepValue1.reverse();

          yyBase   = yyRepetition1;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue(";")) {

            yyValue = SList.create (h, tl);

            return yyResult.createValue(yyValue, yyError);
          } else {
            yyError = yyError.select("';' expected", yyBase);
          }
        } // End scope for tl.
      }
    }

    // Done.
    yyError = yyError.select("options expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal parser.Parser.Option.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pOption(final int yyStart) throws IOException {
    ParserColumn yyColumn = (ParserColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fOption) 
      yyColumn.chunk1.fOption = pOption$1(yyStart);
    return yyColumn.chunk1.fOption;
  }

  /** Actually parse parser.Parser.Option. */
  private Result pOption$1(final int yyStart) throws IOException {
    Result       yyResult;
    int          yyBase;
    SyntaxOption yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pWord(yyStart);
    if (yyResult.hasValue("defaultIndent")) {

      yyBase   = yyResult.index;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue("(")) {

        yyResult = pDecDigits(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          String d = yyResult.semanticValue();

          yyBase   = yyResult.index;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue(")")) {

            yyValue = new Indentation (Integer.parseInt (d));

            if (yyValue instanceof Object) {
              setLocation((Object)yyValue, yyStart);
            }
            return yyResult.createValue(yyValue, yyError);
          } else {
            yyError = yyError.select("')' expected", yyBase);
          }
        }
      } else {
        yyError = yyError.select("'(' expected", yyBase);
      }
    }

    // Alternative 2.

    yyResult = pWord(yyStart);
    if (yyResult.hasValue("defaultWidth")) {

      yyBase   = yyResult.index;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue("(")) {

        yyResult = pDecDigits(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          String d = yyResult.semanticValue();

          yyBase   = yyResult.index;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue(")")) {

            yyValue = new Width (Integer.parseInt (d));

            if (yyValue instanceof Object) {
              setLocation((Object)yyValue, yyStart);
            }
            return yyResult.createValue(yyValue, yyError);
          } else {
            yyError = yyError.select("')' expected", yyBase);
          }
        }
      } else {
        yyError = yyError.select("'(' expected", yyBase);
      }
    }

    // Alternative 3.

    yyResult = pWord(yyStart);
    if (yyResult.hasValue("relativeFilenames")) {

      yyValue = new RelativeFilenames ();

      if (yyValue instanceof Object) {
        setLocation((Object)yyValue, yyStart);
      }
      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 4.

    yyResult = pWord(yyStart);
    if (yyResult.hasValue("setOfString")) {

      yyBase   = yyResult.index;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue("(")) {

        yyResult = pWord(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          String n = yyResult.semanticValue();

          yyBase   = yyResult.index;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue(")")) {

            yyValue = new SetOfString (n);

            if (yyValue instanceof Object) {
              setLocation((Object)yyValue, yyStart);
            }
            return yyResult.createValue(yyValue, yyError);
          } else {
            yyError = yyError.select("')' expected", yyBase);
          }
        }
      } else {
        yyError = yyError.select("'(' expected", yyBase);
      }
    }

    // Alternative 5.

    yyResult = pWord(yyStart);
    if (yyResult.hasValue("verbose")) {

      yyValue = new Verbose ();

      if (yyValue instanceof Object) {
        setLocation((Object)yyValue, yyStart);
      }
      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("option expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal parser.Parser.Rule.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pRule(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    Rule       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pGrammarRule(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyBase   = yyResult.index;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue(".")) {

        return yyResult.createValue(yyValue, yyError);
      } else {
        yyError = yyError.select("'.' expected", yyBase);
      }
    }

    // Alternative 2.

    yyResult = pRatsSection(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal parser.Parser.GrammarRule.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pGrammarRule(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    int        yyOption1;
    Object     yyOpValue1;
    Rule       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pIdnDef(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      IdnDef i = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyBase   = yyChoice1;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue(":")) {

        yyResult = pStringRuleType(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          IdnUse t = yyResult.semanticValue();

          yyBase   = yyResult.index;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue("=")) {

            yyResult = pStringAlternatives(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              List<Element> alts = yyResult.semanticValue();

              yyValue = new StringRule (i, t, alts);

              if (yyValue instanceof Object) {
                setLocation((Object)yyValue, yyStart);
              }
              return yyResult.createValue(yyValue, yyError);
            }
          } else {
            yyError = yyError.select("'=' expected", yyBase);
          }
        }
      } else {
        yyError = yyError.select("':' expected", yyBase);
      }

      // Nested alternative 2.

      yyOption1  = yyChoice1;
      yyOpValue1 = null;

      yyResult = pType(yyOption1);
      yyError  = yyResult.select(yyError, yyOption1);
      if (yyResult.hasValue()) {
        IdnUse v$el$1 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = v$el$1;
      }
      { // Start scope for t.
        IdnUse t = cast(yyOpValue1);

        yyOpValue1 = null;

        yyResult = pRuleAnnotations(yyOption1);
        yyError  = yyResult.select(yyError, yyOption1);
        if (yyResult.hasValue()) {
          List<RuleAnnotation> v$el$2 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$2;
        }
        { // Start scope for anns.
          List<RuleAnnotation> anns = cast(yyOpValue1);

          yyBase   = yyOption1;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue("=")) {

            yyResult = pTreeAlternatives(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              List<Alternative> alts = yyResult.semanticValue();

              yyValue = new ASTRule (i, t, alts, false, anns);

              if (yyValue instanceof Object) {
                setLocation((Object)yyValue, yyStart);
              }
              return yyResult.createValue(yyValue, yyError);
            }
          } else {
            yyError = yyError.select("'=' expected", yyBase);
          }
        } // End scope for anns.
      } // End scope for t.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal parser.Parser.StringRuleType.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pStringRuleType(final int yyStart) throws IOException {
    Result     yyResult;
    IdnUse     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pStringType(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pTokenType(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pVoidType(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal parser.Parser.StringType.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pStringType(final int yyStart) throws IOException {
    ParserColumn yyColumn = (ParserColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fStringType) 
      yyColumn.chunk1.fStringType = pStringType$1(yyStart);
    return yyColumn.chunk1.fStringType;
  }

  /** Actually parse parser.Parser.StringType. */
  private Result pStringType$1(final int yyStart) throws IOException {
    Result     yyResult;
    IdnUse     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pWord(yyStart);
    if (yyResult.hasValue("String")) {

      yyValue = new IdnUse ("String");

      if (yyValue instanceof Object) {
        setLocation((Object)yyValue, yyStart);
      }
      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("string type expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal parser.Parser.TokenType.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTokenType(final int yyStart) throws IOException {
    Result     yyResult;
    IdnUse     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pWord(yyStart);
    if (yyResult.hasValue("Token")) {

      yyValue = new IdnUse ("Token");

      if (yyValue instanceof Object) {
        setLocation((Object)yyValue, yyStart);
      }
      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("token type expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal parser.Parser.VoidType.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pVoidType(final int yyStart) throws IOException {
    Result     yyResult;
    IdnUse     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pWord(yyStart);
    if (yyResult.hasValue("Void")) {

      yyValue = new IdnUse ("Void");

      if (yyValue instanceof Object) {
        setLocation((Object)yyValue, yyStart);
      }
      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("void type expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal parser.Parser.Type.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pType(final int yyStart) throws IOException {
    ParserColumn yyColumn = (ParserColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fType) 
      yyColumn.chunk1.fType = pType$1(yyStart);
    return yyColumn.chunk1.fType;
  }

  /** Actually parse parser.Parser.Type. */
  private Result pType$1(final int yyStart) throws IOException {
    Result     yyResult;
    IdnUse     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue(":")) {

      yyResult = pIdnUse(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        yyValue = yyResult.semanticValue();

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("type expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal parser.Parser.StringAlternatives.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pStringAlternatives(final int yyStart) throws IOException {
    Result        yyResult;
    int           yyBase;
    int           yyRepetition1;
    List<Element> yyRepValue1;
    List<Element> yyValue;
    ParseError    yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pStringElement(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Element h = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = List$.MODULE$.empty();
      while (true) {

        yyBase   = yyRepetition1;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue("|")) {

          yyResult = pStringElement(yyResult.index);
          yyError  = yyResult.select(yyError, yyRepetition1);
          if (yyResult.hasValue()) {
            Element v$el$1 = yyResult.semanticValue();

            yyRepetition1 = yyResult.index;
            yyRepValue1   = new $colon$colon<Element>(v$el$1, yyRepValue1);
            continue;
          }
        } else {
          yyError = yyError.select("'|' expected", yyBase);
        }
        break;
      }
      { // Start scope for tl.
        List<Element> tl = yyRepValue1.reverse();

        yyValue = SList.create (h, tl);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for tl.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal parser.Parser.TreeAlternatives.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTreeAlternatives(final int yyStart) throws IOException {
    Result            yyResult;
    int               yyBase;
    int               yyRepetition1;
    List<Alternative> yyRepValue1;
    List<Alternative> yyValue;
    ParseError        yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pTreeAlternative(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Alternative h = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = List$.MODULE$.empty();
      while (true) {

        yyBase   = yyRepetition1;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue("|")) {

          yyResult = pTreeAlternative(yyResult.index);
          yyError  = yyResult.select(yyError, yyRepetition1);
          if (yyResult.hasValue()) {
            Alternative v$el$1 = yyResult.semanticValue();

            yyRepetition1 = yyResult.index;
            yyRepValue1   = new $colon$colon<Alternative>(v$el$1, yyRepValue1);
            continue;
          }
        } else {
          yyError = yyError.select("'|' expected", yyBase);
        }
        break;
      }
      { // Start scope for tl.
        List<Alternative> tl = yyRepValue1.reverse();

        yyValue = SList.create (h, tl);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for tl.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal parser.Parser.TreeAlternative.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTreeAlternative(final int yyStart) throws IOException {
    ParserColumn yyColumn = (ParserColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fTreeAlternative) 
      yyColumn.chunk1.fTreeAlternative = pTreeAlternative$1(yyStart);
    return yyColumn.chunk1.fTreeAlternative;
  }

  /** Actually parse parser.Parser.TreeAlternative. */
  private Result pTreeAlternative$1(final int yyStart) throws IOException {
    Result              yyResult;
    int                 yyOption1;
    List<AltAnnotation> yyOpValue1;
    Alternative         yyValue;
    ParseError          yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pTreeAlternative$$Star1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      List<Element> es = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pAltAnnotations(yyOption1);
      yyError  = yyResult.select(yyError, yyOption1);
      if (yyResult.hasValue()) {
        List<AltAnnotation> v$el$3 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = v$el$3;
      }
      { // Start scope for as.
        List<AltAnnotation> as = yyOpValue1;

        yyValue = new Alternative (es, as, new DefaultAction ());

        if (yyValue instanceof Object) {
          setLocation((Object)yyValue, yyStart);
        }
        return new SemanticValue(yyValue, yyOption1, yyError);
      } // End scope for as.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal parser.Parser.TreeAlternative$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTreeAlternative$$Star1(final int yyStart) 
    throws IOException {

    ParserColumn yyColumn = (ParserColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fTreeAlternative$$Star1) 
      yyColumn.chunk1.fTreeAlternative$$Star1 = pTreeAlternative$$Star1$1(yyStart);
    return yyColumn.chunk1.fTreeAlternative$$Star1;
  }

  /** Actually parse parser.Parser.TreeAlternative$$Star1. */
  private Result pTreeAlternative$$Star1$1(final int yyStart) 
    throws IOException {

    Result        yyResult;
    List<Element> yyValue;
    ParseError    yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pTreeElement(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Element v$el$1 = yyResult.semanticValue();

      yyResult = pTreeAlternative$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        List<Element> v$2 = yyResult.semanticValue();

        yyValue = new $colon$colon<Element>(v$el$1, v$2);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyValue = List$.MODULE$.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal parser.Parser.StringElement.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pStringElement(final int yyStart) throws IOException {
    ParserColumn yyColumn = (ParserColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fStringElement) 
      yyColumn.chunk1.fStringElement = pStringElement$1(yyStart);
    return yyColumn.chunk1.fStringElement;
  }

  /** Actually parse parser.Parser.StringElement. */
  private Result pStringElement$1(final int yyStart) throws IOException {
    Result     yyResult;
    Element    yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pStringElement1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Element seed = yyResult.semanticValue();

      yyResult = pStringElement$$Plus1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        List<Action<Element>> actions = yyResult.semanticValue();

        yyValue = apply (actions, seed);

        if (yyValue instanceof Object) {
          setLocation((Object)yyValue, yyStart);
        }
        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyResult = pStringElement1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal parser.Parser.StringElement$$Plus1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pStringElement$$Plus1(final int yyStart) throws IOException {
    ParserColumn yyColumn = (ParserColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fStringElement$$Plus1) 
      yyColumn.chunk1.fStringElement$$Plus1 = pStringElement$$Plus1$1(yyStart);
    return yyColumn.chunk1.fStringElement$$Plus1;
  }

  /** Actually parse parser.Parser.StringElement$$Plus1. */
  private Result pStringElement$$Plus1$1(final int yyStart) 
    throws IOException {

    Result                yyResult;
    List<Action<Element>> yyValue;
    ParseError            yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pStringElementAltTail(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Action<Element> v$el$2 = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pStringElement$$Plus1(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        List<Action<Element>> v$3 = yyResult.semanticValue();

        yyValue = new $colon$colon<Action<Element>>(v$el$2, v$3);

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 2.

      yyValue = Nil$.MODULE$.$colon$colon(v$el$2);

      return new SemanticValue(yyValue, yyChoice1, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal parser.Parser.StringElementAltTail.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pStringElementAltTail(final int yyStart) throws IOException {
    Result          yyResult;
    Action<Element> yyValue;
    ParseError      yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("/")) {

      yyResult = pStringElement(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Element right = yyResult.semanticValue();

        yyValue = new Action<Element> () {
          public Element run (Element left) {
            return new Alt (left, right);
          }
        };

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("string element alt tail expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal parser.Parser.StringElement1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pStringElement1(final int yyStart) throws IOException {
    ParserColumn yyColumn = (ParserColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fStringElement1) 
      yyColumn.chunk1.fStringElement1 = pStringElement1$1(yyStart);
    return yyColumn.chunk1.fStringElement1;
  }

  /** Actually parse parser.Parser.StringElement1. */
  private Result pStringElement1$1(final int yyStart) throws IOException {
    Result     yyResult;
    Element    yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pStringElement2(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Element seed = yyResult.semanticValue();

      yyResult = pStringElement1$$Plus1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        List<Action<Element>> actions = yyResult.semanticValue();

        yyValue = apply (actions, seed);

        if (yyValue instanceof Object) {
          setLocation((Object)yyValue, yyStart);
        }
        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyResult = pStringElement2(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal parser.Parser.StringElement1$$Plus1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pStringElement1$$Plus1(final int yyStart) 
    throws IOException {

    ParserColumn yyColumn = (ParserColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fStringElement1$$Plus1) 
      yyColumn.chunk2.fStringElement1$$Plus1 = pStringElement1$$Plus1$1(yyStart);
    return yyColumn.chunk2.fStringElement1$$Plus1;
  }

  /** Actually parse parser.Parser.StringElement1$$Plus1. */
  private Result pStringElement1$$Plus1$1(final int yyStart) 
    throws IOException {

    Result                yyResult;
    List<Action<Element>> yyValue;
    ParseError            yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pStringElementSeqnTail(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Action<Element> v$el$2 = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pStringElement1$$Plus1(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        List<Action<Element>> v$3 = yyResult.semanticValue();

        yyValue = new $colon$colon<Action<Element>>(v$el$2, v$3);

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 2.

      yyValue = Nil$.MODULE$.$colon$colon(v$el$2);

      return new SemanticValue(yyValue, yyChoice1, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal parser.Parser.StringElementSeqnTail.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pStringElementSeqnTail(final int yyStart) 
    throws IOException {

    Result          yyResult;
    Action<Element> yyValue;
    ParseError      yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pStringElement2(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Element right = yyResult.semanticValue();

      yyValue = new Action<Element> () {
        public Element run (Element left) {
          return new Seqn (left, right);
        }
      };

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal parser.Parser.StringElement2.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pStringElement2(final int yyStart) throws IOException {
    ParserColumn yyColumn = (ParserColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fStringElement2) 
      yyColumn.chunk2.fStringElement2 = pStringElement2$1(yyStart);
    return yyColumn.chunk2.fStringElement2;
  }

  /** Actually parse parser.Parser.StringElement2. */
  private Result pStringElement2$1(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    Element    yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pPrimary(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Element e1 = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyBase   = yyChoice1;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue("**")) {

        yyResult = pPrimary(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Element e2 = yyResult.semanticValue();

          yyValue = new Rep (true, e1, e2);

          if (yyValue instanceof Object) {
            setLocation((Object)yyValue, yyStart);
          }
          return yyResult.createValue(yyValue, yyError);
        }
      } else {
        yyError = yyError.select("'**' expected", yyBase);
      }

      // Nested alternative 2.

      yyBase   = yyChoice1;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue("++")) {

        yyResult = pPrimary(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Element e2 = yyResult.semanticValue();

          yyValue = new Rep (false, e1, e2);

          if (yyValue instanceof Object) {
            setLocation((Object)yyValue, yyStart);
          }
          return yyResult.createValue(yyValue, yyError);
        }
      } else {
        yyError = yyError.select("'++' expected", yyBase);
      }
    }

    // Alternative 2.

    yyResult = pPrimary(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Element e = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyBase   = yyChoice1;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue("*")) {

        yyValue = new Rep (true, e, new Epsilon ());

        if (yyValue instanceof Object) {
          setLocation((Object)yyValue, yyStart);
        }
        return yyResult.createValue(yyValue, yyError);
      } else {
        yyError = yyError.select("'*' expected", yyBase);
      }

      // Nested alternative 2.

      yyBase   = yyChoice1;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue("+")) {

        yyValue = new Rep (false, e, new Epsilon ());

        if (yyValue instanceof Object) {
          setLocation((Object)yyValue, yyStart);
        }
        return yyResult.createValue(yyValue, yyError);
      } else {
        yyError = yyError.select("'+' expected", yyBase);
      }

      // Nested alternative 3.

      yyBase   = yyChoice1;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue("?")) {

        yyValue = new Opt (e);

        if (yyValue instanceof Object) {
          setLocation((Object)yyValue, yyStart);
        }
        return yyResult.createValue(yyValue, yyError);
      } else {
        yyError = yyError.select("'?' expected", yyBase);
      }
    }

    // Alternative 3.

    yyResult = pPrimary(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal parser.Parser.Primary.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pPrimary(final int yyStart) throws IOException {
    ParserColumn yyColumn = (ParserColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fPrimary) 
      yyColumn.chunk2.fPrimary = pPrimary$1(yyStart);
    return yyColumn.chunk2.fPrimary;
  }

  /** Actually parse parser.Parser.Primary. */
  private Result pPrimary$1(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    Element    yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("(")) {

      yyResult = pStringElement(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        yyValue = yyResult.semanticValue();

        yyBase   = yyResult.index;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue(")")) {

          return yyResult.createValue(yyValue, yyError);
        } else {
          yyError = yyError.select("')' expected", yyBase);
        }
      }
    }

    // Alternative 2.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("!")) {

      yyResult = pPrimary(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Element p = yyResult.semanticValue();

        yyValue = new Not (p);

        if (yyValue instanceof Object) {
          setLocation((Object)yyValue, yyStart);
        }
        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 3.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("&")) {

      yyResult = pPrimary(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Element p = yyResult.semanticValue();

        yyValue = new And (p);

        if (yyValue instanceof Object) {
          setLocation((Object)yyValue, yyStart);
        }
        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 4.

    yyResult = pLiteral(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyResult = pSpacing(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 5.

    yyResult = pIdnUse(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      IdnUse i = yyResult.semanticValue();

      yyValue = new NonTerminal (new NTName (i));

      if (yyValue instanceof Object) {
        setLocation((Object)yyValue, yyStart);
      }
      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("primary expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal parser.Parser.TreeElement.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTreeElement(final int yyStart) throws IOException {
    Result     yyResult;
    Element    yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pFormatting(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pTreeFactor(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal parser.Parser.TreeFactor.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTreeFactor(final int yyStart) throws IOException {
    ParserColumn yyColumn = (ParserColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fTreeFactor) 
      yyColumn.chunk2.fTreeFactor = pTreeFactor$1(yyStart);
    return yyColumn.chunk2.fTreeFactor;
  }

  /** Actually parse parser.Parser.TreeFactor. */
  private Result pTreeFactor$1(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    Element    yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pTreePrimary(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Element e1 = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyBase   = yyChoice1;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue("**")) {

        yyResult = pTreePrimary(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Element e2 = yyResult.semanticValue();

          yyValue = new Rep (true, e1, e2);

          if (yyValue instanceof Object) {
            setLocation((Object)yyValue, yyStart);
          }
          return yyResult.createValue(yyValue, yyError);
        }
      } else {
        yyError = yyError.select("'**' expected", yyBase);
      }

      // Nested alternative 2.

      yyBase   = yyChoice1;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue("++")) {

        yyResult = pTreePrimary(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Element e2 = yyResult.semanticValue();

          yyValue = new Rep (false, e1, e2);

          if (yyValue instanceof Object) {
            setLocation((Object)yyValue, yyStart);
          }
          return yyResult.createValue(yyValue, yyError);
        }
      } else {
        yyError = yyError.select("'++' expected", yyBase);
      }
    }

    // Alternative 2.

    yyResult = pTreePrimary(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Element e = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyBase   = yyChoice1;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue("*")) {

        yyValue = new Rep (true, e, new Epsilon ());

        if (yyValue instanceof Object) {
          setLocation((Object)yyValue, yyStart);
        }
        return yyResult.createValue(yyValue, yyError);
      } else {
        yyError = yyError.select("'*' expected", yyBase);
      }

      // Nested alternative 2.

      yyBase   = yyChoice1;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue("+")) {

        yyValue = new Rep (false, e, new Epsilon ());

        if (yyValue instanceof Object) {
          setLocation((Object)yyValue, yyStart);
        }
        return yyResult.createValue(yyValue, yyError);
      } else {
        yyError = yyError.select("'+' expected", yyBase);
      }

      // Nested alternative 3.

      yyBase   = yyChoice1;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue("?")) {

        yyValue = new Opt (e);

        if (yyValue instanceof Object) {
          setLocation((Object)yyValue, yyStart);
        }
        return yyResult.createValue(yyValue, yyError);
      } else {
        yyError = yyError.select("'?' expected", yyBase);
      }
    }

    // Alternative 3.

    yyResult = pTreePrimary(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal parser.Parser.TreePrimary.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTreePrimary(final int yyStart) throws IOException {
    ParserColumn yyColumn = (ParserColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fTreePrimary) 
      yyColumn.chunk2.fTreePrimary = pTreePrimary$1(yyStart);
    return yyColumn.chunk2.fTreePrimary;
  }

  /** Actually parse parser.Parser.TreePrimary. */
  private Result pTreePrimary$1(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    Element    yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("(")) {

      yyResult = pTreeAtMostOneNonterm(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        yyValue = yyResult.semanticValue();

        yyBase   = yyResult.index;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue(")")) {

          return yyResult.createValue(yyValue, yyError);
        } else {
          yyError = yyError.select("')' expected", yyBase);
        }
      }
    }

    // Alternative 2.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("!")) {

      yyResult = pTreePrimary(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Element p = yyResult.semanticValue();

        yyValue = new Not (p);

        if (yyValue instanceof Object) {
          setLocation((Object)yyValue, yyStart);
        }
        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 3.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("&")) {

      yyResult = pTreePrimary(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Element p = yyResult.semanticValue();

        yyValue = new And (p);

        if (yyValue instanceof Object) {
          setLocation((Object)yyValue, yyStart);
        }
        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 4.

    yyResult = pTreeLiteral(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 5.

    yyResult = pTreeNonterm(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("tree primary expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal parser.Parser.TreeNonterm.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTreeNonterm(final int yyStart) throws IOException {
    ParserColumn yyColumn = (ParserColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fTreeNonterm) 
      yyColumn.chunk2.fTreeNonterm = pTreeNonterm$1(yyStart);
    return yyColumn.chunk2.fTreeNonterm;
  }

  /** Actually parse parser.Parser.TreeNonterm. */
  private Result pTreeNonterm$1(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    Element    yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pIdentifier(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String i = yyResult.semanticValue();

      yyBase   = yyResult.index;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue("[")) {

        yyResult = pDecDigits(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          String d = yyResult.semanticValue();

          yyBase   = yyResult.index;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue("]")) {

            yyValue = new Block (i, Integer.parseInt (d));

            if (yyValue instanceof Object) {
              setLocation((Object)yyValue, yyStart);
            }
            return yyResult.createValue(yyValue, yyError);
          } else {
            yyError = yyError.select("']' expected", yyBase);
          }
        }
      } else {
        yyError = yyError.select("'[' expected", yyBase);
      }
    }

    // Alternative 2.

    yyResult = pIdnUse(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      IdnUse i = yyResult.semanticValue();

      yyValue = new NonTerminal (new NTName (i));

      if (yyValue instanceof Object) {
        setLocation((Object)yyValue, yyStart);
      }
      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal parser.Parser.TreeAtMostOneNonterm.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTreeAtMostOneNonterm(final int yyStart) throws IOException {
    ParserColumn yyColumn = (ParserColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fTreeAtMostOneNonterm) 
      yyColumn.chunk2.fTreeAtMostOneNonterm = pTreeAtMostOneNonterm$1(yyStart);
    return yyColumn.chunk2.fTreeAtMostOneNonterm;
  }

  /** Actually parse parser.Parser.TreeAtMostOneNonterm. */
  private Result pTreeAtMostOneNonterm$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Element    yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pTreeNonterm(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Element i = yyResult.semanticValue();

      yyResult = pTreeNoNonterms(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Element ls = yyResult.semanticValue();

        yyValue = new Seqn (i, ls);

        if (yyValue instanceof Object) {
          setLocation((Object)yyValue, yyStart);
        }
        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyResult = pTreeLiteral(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Element l = yyResult.semanticValue();

      yyResult = pTreeAtMostOneNonterm(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Element es = yyResult.semanticValue();

        yyValue = new Seqn (l, es);

        if (yyValue instanceof Object) {
          setLocation((Object)yyValue, yyStart);
        }
        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 3.

    yyResult = pFormatting(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Element f = yyResult.semanticValue();

      yyResult = pTreeAtMostOneNonterm(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Element es = yyResult.semanticValue();

        yyValue = new Seqn (f, es);

        if (yyValue instanceof Object) {
          setLocation((Object)yyValue, yyStart);
        }
        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 4.

    yyResult = pTreeLiteral(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 5.

    yyResult = pTreeNonterm(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal parser.Parser.TreeNoNonterms.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTreeNoNonterms(final int yyStart) throws IOException {
    Result                yyResult;
    int                   yyRepetition1;
    boolean               yyRepeated1;
    List<Action<Element>> yyRepValue1;
    Element               yyValue;
    ParseError            yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pTreeNoNonterm(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Element seed = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepeated1   = false;
      yyRepValue1   = List$.MODULE$.empty();
      while (true) {

        yyResult = pTreeNoNontermsTail(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Action<Element> v$el$2 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepeated1   = true;
          yyRepValue1   = new $colon$colon<Action<Element>>(v$el$2, yyRepValue1);
          continue;
        }
        break;
      }

      if (yyRepeated1) {
        List<Action<Element>> actions = yyRepValue1.reverse();

        yyValue = apply (actions, seed);

        if (yyValue instanceof Object) {
          setLocation((Object)yyValue, yyStart);
        }
        return new SemanticValue(yyValue, yyRepetition1, yyError);
      }
    }

    // Alternative 2.

    yyResult = pTreeNoNonterm(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal parser.Parser.TreeNoNontermsTail.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTreeNoNontermsTail(final int yyStart) throws IOException {
    Result          yyResult;
    Action<Element> yyValue;
    ParseError      yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pTreeNoNonterm(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Element right = yyResult.semanticValue();

      yyValue = new Action<Element> () {
        public Element run (Element left) {
          return new Seqn (left, right);
        }
      };

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal parser.Parser.TreeNoNonterm.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTreeNoNonterm(final int yyStart) throws IOException {
    ParserColumn yyColumn = (ParserColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fTreeNoNonterm) 
      yyColumn.chunk2.fTreeNoNonterm = pTreeNoNonterm$1(yyStart);
    return yyColumn.chunk2.fTreeNoNonterm;
  }

  /** Actually parse parser.Parser.TreeNoNonterm. */
  private Result pTreeNoNonterm$1(final int yyStart) throws IOException {
    Result     yyResult;
    Element    yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pTreeLiteral(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pFormatting(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal parser.Parser.TreeLiteral.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTreeLiteral(final int yyStart) throws IOException {
    ParserColumn yyColumn = (ParserColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fTreeLiteral) 
      yyColumn.chunk2.fTreeLiteral = pTreeLiteral$1(yyStart);
    return yyColumn.chunk2.fTreeLiteral;
  }

  /** Actually parse parser.Parser.TreeLiteral. */
  private Result pTreeLiteral$1(final int yyStart) throws IOException {
    Result     yyResult;
    Element    yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pLiteral(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyResult = pSpacing(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal parser.Parser.Formatting.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pFormatting(final int yyStart) throws IOException {
    ParserColumn yyColumn = (ParserColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fFormatting) 
      yyColumn.chunk2.fFormatting = pFormatting$1(yyStart);
    return yyColumn.chunk2.fFormatting;
  }

  /** Actually parse parser.Parser.Formatting. */
  private Result pFormatting$1(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    Element    yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("\\n")) {

      yyValue = new Newline ();

      if (yyValue instanceof Object) {
        setLocation((Object)yyValue, yyStart);
      }
      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pWord(yyStart);
    if (yyResult.hasValue("nest")) {

      yyBase   = yyResult.index;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue("(")) {

        yyResult = pTreeFactor(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Element e = yyResult.semanticValue();

          yyBase   = yyResult.index;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue(")")) {

            yyValue = new Nest (e, false);

            if (yyValue instanceof Object) {
              setLocation((Object)yyValue, yyStart);
            }
            return yyResult.createValue(yyValue, yyError);
          } else {
            yyError = yyError.select("')' expected", yyBase);
          }
        }
      } else {
        yyError = yyError.select("'(' expected", yyBase);
      }
    }

    // Alternative 3.

    yyResult = pWord(yyStart);
    if (yyResult.hasValue("nestnl")) {

      yyBase   = yyResult.index;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue("(")) {

        yyResult = pTreeFactor(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Element e = yyResult.semanticValue();

          yyBase   = yyResult.index;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue(")")) {

            yyValue = new Nest (e, true);

            if (yyValue instanceof Object) {
              setLocation((Object)yyValue, yyStart);
            }
            return yyResult.createValue(yyValue, yyError);
          } else {
            yyError = yyError.select("')' expected", yyBase);
          }
        }
      } else {
        yyError = yyError.select("'(' expected", yyBase);
      }
    }

    // Alternative 4.

    yyResult = pWord(yyStart);
    if (yyResult.hasValue("sp")) {

      yyValue = new Space ();

      if (yyValue instanceof Object) {
        setLocation((Object)yyValue, yyStart);
      }
      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("formatting expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal parser.Parser.RuleAnnotations.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pRuleAnnotations(final int yyStart) throws IOException {
    Result               yyResult;
    int                  yyBase;
    List<RuleAnnotation> yyValue;
    ParseError           yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("{")) {

      yyResult = pRuleAnnotationList(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        yyValue = yyResult.semanticValue();

        yyBase   = yyResult.index;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue("}")) {

          return yyResult.createValue(yyValue, yyError);
        } else {
          yyError = yyError.select("'}' expected", yyBase);
        }
      }
    }

    // Done.
    yyError = yyError.select("rule annotations expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal parser.Parser.RuleAnnotationList.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pRuleAnnotationList(final int yyStart) throws IOException {
    Result               yyResult;
    int                  yyBase;
    int                  yyRepetition1;
    List<RuleAnnotation> yyRepValue1;
    List<RuleAnnotation> yyValue;
    ParseError           yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pRuleAnnotation(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      RuleAnnotation h = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = List$.MODULE$.empty();
      while (true) {

        yyBase   = yyRepetition1;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue(",")) {

          yyResult = pRuleAnnotation(yyResult.index);
          yyError  = yyResult.select(yyError, yyRepetition1);
          if (yyResult.hasValue()) {
            RuleAnnotation v$el$1 = yyResult.semanticValue();

            yyRepetition1 = yyResult.index;
            yyRepValue1   = new $colon$colon<RuleAnnotation>(v$el$1, yyRepValue1);
            continue;
          }
        } else {
          yyError = yyError.select("',' expected", yyBase);
        }
        break;
      }
      { // Start scope for tl.
        List<RuleAnnotation> tl = yyRepValue1.reverse();

        yyValue = SList.create (h, tl);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for tl.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal parser.Parser.RuleAnnotation.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pRuleAnnotation(final int yyStart) throws IOException {
    ParserColumn yyColumn = (ParserColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fRuleAnnotation) 
      yyColumn.chunk3.fRuleAnnotation = pRuleAnnotation$1(yyStart);
    return yyColumn.chunk3.fRuleAnnotation;
  }

  /** Actually parse parser.Parser.RuleAnnotation. */
  private Result pRuleAnnotation$1(final int yyStart) throws IOException {
    Result         yyResult;
    RuleAnnotation yyValue;
    ParseError     yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pWord(yyStart);
    if (yyResult.hasValue("line")) {

      yyValue = new Line ();

      if (yyValue instanceof Object) {
        setLocation((Object)yyValue, yyStart);
      }
      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pWord(yyStart);
    if (yyResult.hasValue("nested")) {

      yyValue = new Nested ();

      if (yyValue instanceof Object) {
        setLocation((Object)yyValue, yyStart);
      }
      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pWord(yyStart);
    if (yyResult.hasValue("paren")) {

      yyValue = new Parenthesized ();

      if (yyValue instanceof Object) {
        setLocation((Object)yyValue, yyStart);
      }
      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 4.

    yyResult = pWord(yyStart);
    if (yyResult.hasValue("nospacing")) {

      yyValue = new NoSpacing ();

      if (yyValue instanceof Object) {
        setLocation((Object)yyValue, yyStart);
      }
      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("rule annotation expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal parser.Parser.AltAnnotations.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAltAnnotations(final int yyStart) throws IOException {
    Result              yyResult;
    int                 yyBase;
    List<AltAnnotation> yyValue;
    ParseError          yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("{")) {

      yyResult = pAltAnnotationList(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        yyValue = yyResult.semanticValue();

        yyBase   = yyResult.index;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue("}")) {

          return yyResult.createValue(yyValue, yyError);
        } else {
          yyError = yyError.select("'}' expected", yyBase);
        }
      }
    }

    // Done.
    yyError = yyError.select("alt annotations expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal parser.Parser.AltAnnotationList.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAltAnnotationList(final int yyStart) throws IOException {
    Result              yyResult;
    int                 yyBase;
    int                 yyRepetition1;
    List<AltAnnotation> yyRepValue1;
    List<AltAnnotation> yyValue;
    ParseError          yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pAltAnnotation(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      AltAnnotation h = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = List$.MODULE$.empty();
      while (true) {

        yyBase   = yyRepetition1;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue(",")) {

          yyResult = pAltAnnotation(yyResult.index);
          yyError  = yyResult.select(yyError, yyRepetition1);
          if (yyResult.hasValue()) {
            AltAnnotation v$el$1 = yyResult.semanticValue();

            yyRepetition1 = yyResult.index;
            yyRepValue1   = new $colon$colon<AltAnnotation>(v$el$1, yyRepValue1);
            continue;
          }
        } else {
          yyError = yyError.select("',' expected", yyBase);
        }
        break;
      }
      { // Start scope for tl.
        List<AltAnnotation> tl = yyRepValue1.reverse();

        yyValue = SList.create (h, tl);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for tl.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal parser.Parser.AltAnnotation.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAltAnnotation(final int yyStart) throws IOException {
    ParserColumn yyColumn = (ParserColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fAltAnnotation) 
      yyColumn.chunk3.fAltAnnotation = pAltAnnotation$1(yyStart);
    return yyColumn.chunk3.fAltAnnotation;
  }

  /** Actually parse parser.Parser.AltAnnotation. */
  private Result pAltAnnotation$1(final int yyStart) throws IOException {
    Result        yyResult;
    int           yyBase;
    AltAnnotation yyValue;
    ParseError    yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pWord(yyStart);
    if (yyResult.hasValue("left")) {

      yyValue = new Associativity (LeftAssoc$.MODULE$);

      if (yyValue instanceof Object) {
        setLocation((Object)yyValue, yyStart);
      }
      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pWord(yyStart);
    if (yyResult.hasValue("none")) {

      yyValue = new Associativity (NonAssoc$.MODULE$);

      if (yyValue instanceof Object) {
        setLocation((Object)yyValue, yyStart);
      }
      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pWord(yyStart);
    if (yyResult.hasValue("right")) {

      yyValue = new Associativity (RightAssoc$.MODULE$);

      if (yyValue instanceof Object) {
        setLocation((Object)yyValue, yyStart);
      }
      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 4.

    yyResult = pIdnDef(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      IdnDef i = yyResult.semanticValue();

      yyValue = new Constructor (i);

      if (yyValue instanceof Object) {
        setLocation((Object)yyValue, yyStart);
      }
      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 5.

    yyResult = pNumber(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String n = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyBase   = yyChoice1;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue(":")) {

        yyResult = pQualIdentifier(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          List<String> m = yyResult.semanticValue();

          yyBase   = yyResult.index;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue(":")) {

            yyResult = pQualIdentifier(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              List<String> t = yyResult.semanticValue();

              yyValue = new Transformation (Integer.parseInt (n), m, t);

              if (yyValue instanceof Object) {
                setLocation((Object)yyValue, yyStart);
              }
              return yyResult.createValue(yyValue, yyError);
            }
          } else {
            yyError = yyError.select("':' expected", yyBase);
          }
        }
      } else {
        yyError = yyError.select("':' expected", yyBase);
      }

      // Nested alternative 2.

      yyValue = new Precedence (Integer.parseInt (n));

      if (yyValue instanceof Object) {
        setLocation((Object)yyValue, yyStart);
      }
      return new SemanticValue(yyValue, yyChoice1, yyError);
    }

    // Done.
    yyError = yyError.select("alt annotation expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal parser.Parser.Number.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNumber(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pDecDigits(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyResult = pSpacing(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal parser.Parser.RatsSection.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pRatsSection(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    Rule       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pRatsRule(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyBase   = yyResult.index;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue(".")) {

        return yyResult.createValue(yyValue, yyError);
      } else {
        yyError = yyError.select("'.' expected", yyBase);
      }
    }

    // Alternative 2.

    yyResult = pRatsBlock(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal parser.Parser.RatsRule.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pRatsRule(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    RatsRule   yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pIdnDef(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      IdnDef i = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyBase   = yyChoice1;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue(":")) {

        yyResult = pStringType(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyBase   = yyResult.index;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue("=")) {

            yyBase   = yyResult.index;
            yyResult = pWord(yyBase);
            if (yyResult.hasValue("rats")) {

              yyResult = pCodeBlock(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                String s = yyResult.semanticValue();

                yyValue = new RatsRule (i, new IdnUse ("String"), s);

                if (yyValue instanceof Object) {
                  setLocation((Object)yyValue, yyStart);
                }
                return yyResult.createValue(yyValue, yyError);
              }
            } else {
              yyError = yyError.select("'rats' expected", yyBase);
            }
          } else {
            yyError = yyError.select("'=' expected", yyBase);
          }
        }
      } else {
        yyError = yyError.select("':' expected", yyBase);
      }

      // Nested alternative 2.

      yyResult = pType(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        IdnUse t = yyResult.semanticValue();

        yyBase   = yyResult.index;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue("=")) {

          yyBase   = yyResult.index;
          yyResult = pWord(yyBase);
          if (yyResult.hasValue("rats")) {

            yyResult = pCodeBlock(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              String s = yyResult.semanticValue();

              yyValue = new RatsRule (i, t, s);

              if (yyValue instanceof Object) {
                setLocation((Object)yyValue, yyStart);
              }
              return yyResult.createValue(yyValue, yyError);
            }
          } else {
            yyError = yyError.select("'rats' expected", yyBase);
          }
        } else {
          yyError = yyError.select("'=' expected", yyBase);
        }
      }

      // Nested alternative 3.

      yyBase   = yyChoice1;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue("=")) {

        yyBase   = yyResult.index;
        yyResult = pWord(yyBase);
        if (yyResult.hasValue("rats")) {

          yyResult = pCodeBlock(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            String s = yyResult.semanticValue();

            yyValue = new RatsRule (i, null, s);

            if (yyValue instanceof Object) {
              setLocation((Object)yyValue, yyStart);
            }
            return yyResult.createValue(yyValue, yyError);
          }
        } else {
          yyError = yyError.select("'rats' expected", yyBase);
        }
      } else {
        yyError = yyError.select("'=' expected", yyBase);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal parser.Parser.RatsBlock.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pRatsBlock(final int yyStart) throws IOException {
    Result     yyResult;
    RatsBlock  yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pWord(yyStart);
    if (yyResult.hasValue("rats")) {

      yyResult = pCodeBlock(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        String s = yyResult.semanticValue();

        yyValue = new RatsBlock (s);

        if (yyValue instanceof Object) {
          setLocation((Object)yyValue, yyStart);
        }
        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("rats block expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal parser.Parser.IdnUse.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pIdnUse(final int yyStart) throws IOException {
    ParserColumn yyColumn = (ParserColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fIdnUse) 
      yyColumn.chunk3.fIdnUse = pIdnUse$1(yyStart);
    return yyColumn.chunk3.fIdnUse;
  }

  /** Actually parse parser.Parser.IdnUse. */
  private Result pIdnUse$1(final int yyStart) throws IOException {
    Result     yyResult;
    IdnUse     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pIdentifier(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String i = yyResult.semanticValue();

      yyValue = new IdnUse (i);

      if (yyValue instanceof Object) {
        setLocation((Object)yyValue, yyStart);
      }
      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal parser.Parser.IdnDef.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pIdnDef(final int yyStart) throws IOException {
    ParserColumn yyColumn = (ParserColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fIdnDef) 
      yyColumn.chunk3.fIdnDef = pIdnDef$1(yyStart);
    return yyColumn.chunk3.fIdnDef;
  }

  /** Actually parse parser.Parser.IdnDef. */
  private Result pIdnDef$1(final int yyStart) throws IOException {
    Result     yyResult;
    IdnDef     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pIdentifier(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String i = yyResult.semanticValue();

      yyValue = new IdnDef (i);

      if (yyValue instanceof Object) {
        setLocation((Object)yyValue, yyStart);
      }
      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal parser.Parser.QualIdentifier.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pQualIdentifier(final int yyStart) throws IOException {
    ParserColumn yyColumn = (ParserColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fQualIdentifier) 
      yyColumn.chunk3.fQualIdentifier = pQualIdentifier$1(yyStart);
    return yyColumn.chunk3.fQualIdentifier;
  }

  /** Actually parse parser.Parser.QualIdentifier. */
  private Result pQualIdentifier$1(final int yyStart) throws IOException {
    Result       yyResult;
    List<String> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pIdentifier(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String h = yyResult.semanticValue();

      yyResult = pQualIdentifier$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        List<String> tl = yyResult.semanticValue();

        yyValue = SList.create (h, tl);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal parser.Parser.QualIdentifier$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pQualIdentifier$$Star1(final int yyStart) 
    throws IOException {

    ParserColumn yyColumn = (ParserColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fQualIdentifier$$Star1) 
      yyColumn.chunk3.fQualIdentifier$$Star1 = pQualIdentifier$$Star1$1(yyStart);
    return yyColumn.chunk3.fQualIdentifier$$Star1;
  }

  /** Actually parse parser.Parser.QualIdentifier$$Star1. */
  private Result pQualIdentifier$$Star1$1(final int yyStart) 
    throws IOException {

    Result       yyResult;
    List<String> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue(".")) {

      yyResult = pIdentifier(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        String v$el$1 = yyResult.semanticValue();

        yyResult = pQualIdentifier$$Star1(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          List<String> v$2 = yyResult.semanticValue();

          yyValue = new $colon$colon<String>(v$el$1, v$2);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyValue = List$.MODULE$.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal parser.Parser.Identifier.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pIdentifier(final int yyStart) throws IOException {
    ParserColumn yyColumn = (ParserColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fIdentifier) 
      yyColumn.chunk3.fIdentifier = pIdentifier$1(yyStart);
    return yyColumn.chunk3.fIdentifier;
  }

  /** Actually parse parser.Parser.Identifier. */
  private Result pIdentifier$1(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pWord(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      if (! contains (KEYWORDS, yyValue)) {

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("identifier expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal parser.Parser.Literal.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pLiteral(final int yyStart) throws IOException {
    ParserColumn yyColumn = (ParserColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fLiteral) 
      yyColumn.chunk3.fLiteral = pLiteral$1(yyStart);
    return yyColumn.chunk3.fLiteral;
  }

  /** Actually parse parser.Parser.Literal. */
  private Result pLiteral$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Element    yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '_':
        {
          yyValue = new Wildcard ();

          if (yyValue instanceof Object) {
            setLocation((Object)yyValue, yyStart);
          }
          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '\"':
        {
          yyResult = pStringLiteral(yyIndex);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            List<String> s = yyResult.semanticValue();

            yyC = character(yyResult.index);
            if ('\"' == yyC) {
              yyIndex = yyResult.index + 1;

              yyValue = new StringLit (new Literal (s));

              if (yyValue instanceof Object) {
                setLocation((Object)yyValue, yyStart);
              }
              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case '\'':
        {
          yyResult = pCharLiteral(yyIndex);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            List<String> s = yyResult.semanticValue();

            yyC = character(yyResult.index);
            if ('\'' == yyC) {
              yyIndex = yyResult.index + 1;

              yyValue = new CharLit (new Literal (s));

              if (yyValue instanceof Object) {
                setLocation((Object)yyValue, yyStart);
              }
              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case '[':
        {
          yyResult = pCharClassContents(yyIndex);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            String s = yyResult.semanticValue();

            yyC = character(yyResult.index);
            if (']' == yyC) {
              yyIndex = yyResult.index + 1;

              yyValue = new CharClass (s);

              if (yyValue instanceof Object) {
                setLocation((Object)yyValue, yyStart);
              }
              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("literal expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal parser.Parser.StringLiteral.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pStringLiteral(final int yyStart) throws IOException {
    Result       yyResult;
    int          yyRepetition1;
    List<String> yyRepValue1;
    List<String> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    yyRepValue1   = List$.MODULE$.empty();
    while (true) {

      yyResult = pStringLiteralChar(yyRepetition1);
      yyError  = yyResult.select(yyError, yyRepetition1);
      if (yyResult.hasValue()) {
        String v$el$1 = yyResult.semanticValue();

        yyRepetition1 = yyResult.index;
        yyRepValue1   = new $colon$colon<String>(v$el$1, yyRepValue1);
        continue;
      }
      break;
    }
    { // Start scope for yyValue.
      yyValue = yyRepValue1.reverse();

      return new SemanticValue(yyValue, yyRepetition1, yyError);
    } // End scope for yyValue.
  }

  // =========================================================================

  /**
   * Parse nonterminal parser.Parser.StringLiteralChar.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pStringLiteralChar(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    boolean    yyPredMatched;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pEscape(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyPredMatched = false;

    yyC = character(yyStart);
    if ('\"' == yyC) {

      yyPredMatched = true;
    }

    if (! yyPredMatched) {

      yyC = character(yyStart);
      if (-1 != yyC) {
        yyIndex = yyStart + 1;
        char c = (char)yyC;

        yyValue = String.valueOf (c);

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    } else {
      yyError = yyError.select("string literal char expected", yyStart);
    }

    // Done.
    yyError = yyError.select("string literal char expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal parser.Parser.CharLiteral.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCharLiteral(final int yyStart) throws IOException {
    Result       yyResult;
    int          yyRepetition1;
    List<String> yyRepValue1;
    List<String> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    yyRepValue1   = List$.MODULE$.empty();
    while (true) {

      yyResult = pCharLiteralChar(yyRepetition1);
      yyError  = yyResult.select(yyError, yyRepetition1);
      if (yyResult.hasValue()) {
        String v$el$1 = yyResult.semanticValue();

        yyRepetition1 = yyResult.index;
        yyRepValue1   = new $colon$colon<String>(v$el$1, yyRepValue1);
        continue;
      }
      break;
    }
    { // Start scope for yyValue.
      yyValue = yyRepValue1.reverse();

      return new SemanticValue(yyValue, yyRepetition1, yyError);
    } // End scope for yyValue.
  }

  // =========================================================================

  /**
   * Parse nonterminal parser.Parser.CharLiteralChar.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCharLiteralChar(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    boolean    yyPredMatched;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pEscape(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyPredMatched = false;

    yyC = character(yyStart);
    if ('\'' == yyC) {

      yyPredMatched = true;
    }

    if (! yyPredMatched) {

      yyC = character(yyStart);
      if (-1 != yyC) {
        yyIndex = yyStart + 1;
        char c = (char)yyC;

        yyValue = String.valueOf (c);

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    } else {
      yyError = yyError.select("char literal char expected", yyStart);
    }

    // Done.
    yyError = yyError.select("char literal char expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal parser.Parser.CharClassContents.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCharClassContents(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyRepetition1;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    while (true) {

      yyResult = pCharClassElement(yyRepetition1);
      yyError  = yyResult.select(yyError, yyRepetition1);
      if (yyResult.hasValue()) {

        yyRepetition1 = yyResult.index;
        continue;
      }
      break;
    }

    yyValue = difference(yyStart, yyRepetition1);

    return new SemanticValue(yyValue, yyRepetition1, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal parser.Parser.CharClassElement.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCharClassElement(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pCharClassCharacter(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyC = character(yyChoice1);
      if ('-' == yyC) {
        yyIndex = yyChoice1 + 1;

        yyResult = pCharClassCharacter(yyIndex);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = null;

          return yyResult.createValue(yyValue, yyError);
        }
      }

      // Nested alternative 2.

      yyValue = null;

      return new SemanticValue(yyValue, yyChoice1, yyError);
    }

    // Done.
    yyError = yyError.select("char class element expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal parser.Parser.CharClassCharacter.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCharClassCharacter(final int yyStart) throws IOException {
    ParserColumn yyColumn = (ParserColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fCharClassCharacter) 
      yyColumn.chunk3.fCharClassCharacter = pCharClassCharacter$1(yyStart);
    return yyColumn.chunk3.fCharClassCharacter;
  }

  /** Actually parse parser.Parser.CharClassCharacter. */
  private Result pCharClassCharacter$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pEscape(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = null;

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '-':
      case '\\':
      case ']':
        /* No match. */
        break;

      default:
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }
      }
    }

    // Done.
    yyError = yyError.select("char class character expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal parser.Parser.Escape.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pEscape(final int yyStart) throws IOException {
    ParserColumn yyColumn = (ParserColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fEscape) 
      yyColumn.chunk3.fEscape = pEscape$1(yyStart);
    return yyColumn.chunk3.fEscape;
  }

  /** Actually parse parser.Parser.Escape. */
  private Result pEscape$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;
      if ('\\' == yyC) {

        final int yyChoice1 = yyIndex;

        // Nested alternative 1.

        yyC = character(yyChoice1);
        if (-1 != yyC) {
          yyIndex = yyChoice1 + 1;

          switch (yyC) {
          case '\"':
          case '\'':
          case '-':
          case '[':
          case '\\':
          case ']':
          case 'b':
          case 'f':
          case 'n':
          case 'r':
          case 't':
            {
              yyValue = difference(yyStart, yyIndex);

              return new SemanticValue(yyValue, yyIndex, yyError);
            }

          case 'u':
            {
              yyResult = pHexQuad(yyIndex);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyValue = difference(yyStart, yyResult.index);

                return yyResult.createValue(yyValue, yyError);
              }
            }
            break;

          default:
            /* No match. */
          }
        }

        // Nested alternative 2.
        { // Start scope for nested choice.

          final int yyChoice2 = yyChoice1;

          // Nested alternative 1.

          yyC = character(yyChoice2);
          if (-1 != yyC) {
            yyIndex = yyChoice2 + 1;

            switch (yyC) {
            case '0':
            case '1':
            case '2':
            case '3':
              {
                yyC = character(yyIndex);
                if (-1 != yyC) {
                  yyIndex = yyIndex + 1;

                  switch (yyC) {
                  case '0':
                  case '1':
                  case '2':
                  case '3':
                  case '4':
                  case '5':
                  case '6':
                  case '7':
                    {
                      yyC = character(yyIndex);
                      if (-1 != yyC) {
                        yyIndex = yyIndex + 1;

                        switch (yyC) {
                        case '0':
                        case '1':
                        case '2':
                        case '3':
                        case '4':
                        case '5':
                        case '6':
                        case '7':
                          {
                            yyValue = difference(yyStart, yyIndex);

                            return new SemanticValue(yyValue, yyIndex, yyError);
                          }

                        default:
                          /* No match. */
                        }
                      }
                    }
                    break;

                  default:
                    /* No match. */
                  }
                }
              }
              break;

            default:
              /* No match. */
            }
          }

          // Nested alternative 2.

          yyC = character(yyChoice2);
          if (-1 != yyC) {
            yyIndex = yyChoice2 + 1;

            switch (yyC) {
            case '0':
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
              {
                final int yyChoice3 = yyIndex;

                // Nested alternative 1.

                yyC = character(yyChoice3);
                if (-1 != yyC) {
                  yyIndex = yyChoice3 + 1;

                  switch (yyC) {
                  case '0':
                  case '1':
                  case '2':
                  case '3':
                  case '4':
                  case '5':
                  case '6':
                  case '7':
                    {
                      yyValue = difference(yyStart, yyIndex);

                      return new SemanticValue(yyValue, yyIndex, yyError);
                    }

                  default:
                    /* No match. */
                  }
                }

                // Nested alternative 2.

                yyValue = difference(yyStart, yyChoice3);

                return new SemanticValue(yyValue, yyChoice3, yyError);
              }

            default:
              /* No match. */
            }
          }
        } // End scope for nested choice.
      }
    }

    // Done.
    yyError = yyError.select("escape expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal parser.Parser.HexQuad.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pHexQuad(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '0':
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9':
      case 'A':
      case 'B':
      case 'C':
      case 'D':
      case 'E':
      case 'F':
      case 'a':
      case 'b':
      case 'c':
      case 'd':
      case 'e':
      case 'f':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;

            switch (yyC) {
            case '0':
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
            case 'A':
            case 'B':
            case 'C':
            case 'D':
            case 'E':
            case 'F':
            case 'a':
            case 'b':
            case 'c':
            case 'd':
            case 'e':
            case 'f':
              {
                yyC = character(yyIndex);
                if (-1 != yyC) {
                  yyIndex = yyIndex + 1;

                  switch (yyC) {
                  case '0':
                  case '1':
                  case '2':
                  case '3':
                  case '4':
                  case '5':
                  case '6':
                  case '7':
                  case '8':
                  case '9':
                  case 'A':
                  case 'B':
                  case 'C':
                  case 'D':
                  case 'E':
                  case 'F':
                  case 'a':
                  case 'b':
                  case 'c':
                  case 'd':
                  case 'e':
                  case 'f':
                    {
                      yyC = character(yyIndex);
                      if (-1 != yyC) {
                        yyIndex = yyIndex + 1;

                        switch (yyC) {
                        case '0':
                        case '1':
                        case '2':
                        case '3':
                        case '4':
                        case '5':
                        case '6':
                        case '7':
                        case '8':
                        case '9':
                        case 'A':
                        case 'B':
                        case 'C':
                        case 'D':
                        case 'E':
                        case 'F':
                        case 'a':
                        case 'b':
                        case 'c':
                        case 'd':
                        case 'e':
                        case 'f':
                          {
                            yyValue = null;

                            return new SemanticValue(yyValue, yyIndex, yyError);
                          }

                        default:
                          /* No match. */
                        }
                      }
                    }
                    break;

                  default:
                    /* No match. */
                  }
                }
              }
              break;

            default:
              /* No match. */
            }
          }
        }
        break;

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("hex quad expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal parser.Parser.DecDigits.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pDecDigits(final int yyStart) throws IOException {
    ParserColumn yyColumn = (ParserColumn)column(yyStart);
    if (null == yyColumn.chunk4) yyColumn.chunk4 = new Chunk4();
    if (null == yyColumn.chunk4.fDecDigits) 
      yyColumn.chunk4.fDecDigits = pDecDigits$1(yyStart);
    return yyColumn.chunk4.fDecDigits;
  }

  /** Actually parse parser.Parser.DecDigits. */
  private Result pDecDigits$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '0':
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9':
        {
          final int yyChoice1 = yyIndex;

          // Nested alternative 1.

          yyResult = pDecDigits(yyChoice1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyValue = difference(yyStart, yyResult.index);

            return yyResult.createValue(yyValue, yyError);
          }

          // Nested alternative 2.

          yyValue = difference(yyStart, yyChoice1);

          return new SemanticValue(yyValue, yyChoice1, yyError);
        }

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("dec digits expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal parser.Parser.Word.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pWord(final int yyStart) throws IOException {
    ParserColumn yyColumn = (ParserColumn)column(yyStart);
    if (null == yyColumn.chunk4) yyColumn.chunk4 = new Chunk4();
    if (null == yyColumn.chunk4.fWord) 
      yyColumn.chunk4.fWord = pWord$1(yyStart);
    return yyColumn.chunk4.fWord;
  }

  /** Actually parse parser.Parser.Word. */
  private Result pWord$1(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pWordCharacters(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyResult = pSpacing(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal parser.Parser.WordCharacters.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pWordCharacters(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    int        yyRepetition1;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;
      char h = (char)yyC;

      if (Character.isJavaIdentifierStart (h)) {

        yyRepetition1 = yyIndex;
        while (true) {

          yyC = character(yyRepetition1);
          if (-1 != yyC) {
            yyIndex = yyRepetition1 + 1;
            char t = (char)yyC;

            if (Character.isJavaIdentifierPart (t)) {

              yyRepetition1 = yyIndex;
              continue;
            }
          }
          break;
        }

        yyValue = difference(yyStart, yyRepetition1);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      }
    }

    // Done.
    yyError = yyError.select("word characters expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal parser.Parser.Symbol.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSymbol(final int yyStart) throws IOException {
    ParserColumn yyColumn = (ParserColumn)column(yyStart);
    if (null == yyColumn.chunk4) yyColumn.chunk4 = new Chunk4();
    if (null == yyColumn.chunk4.fSymbol) 
      yyColumn.chunk4.fSymbol = pSymbol$1(yyStart);
    return yyColumn.chunk4.fSymbol;
  }

  /** Actually parse parser.Parser.Symbol. */
  private Result pSymbol$1(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSymbolCharacters(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyResult = pSpacing(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal parser.Parser.SymbolCharacters.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSymbolCharacters(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '*':
        {
          final int yyChoice1 = yyIndex;

          // Nested alternative 1.

          yyC = character(yyChoice1);
          if (-1 != yyC) {
            yyIndex = yyChoice1 + 1;
            if ('*' == yyC) {

              yyValue = "**";

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }

          // Nested alternative 2.

          yyValue = "*";

          return new SemanticValue(yyValue, yyChoice1, yyError);
        }

      case '+':
        {
          final int yyChoice1 = yyIndex;

          // Nested alternative 1.

          yyC = character(yyChoice1);
          if (-1 != yyC) {
            yyIndex = yyChoice1 + 1;
            if ('+' == yyC) {

              yyValue = "++";

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }

          // Nested alternative 2.

          yyValue = "+";

          return new SemanticValue(yyValue, yyChoice1, yyError);
        }

      case ':':
        {
          yyValue = ":";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '=':
        {
          yyValue = "=";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '/':
        {
          yyValue = "/";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '|':
        {
          yyValue = "|";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '{':
        {
          yyValue = "{";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '}':
        {
          yyValue = "}";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '(':
        {
          yyValue = "(";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case ')':
        {
          yyValue = ")";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '!':
        {
          yyValue = "!";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '&':
        {
          yyValue = "&";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '.':
        {
          yyValue = ".";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case ',':
        {
          yyValue = ",";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '?':
        {
          yyValue = "?";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '[':
        {
          yyValue = "[";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case ']':
        {
          yyValue = "]";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case ';':
        {
          yyValue = ";";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '\\':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('n' == yyC) {

              yyValue = "\\n";

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("symbol characters expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal parser.Parser.Spacing.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSpacing(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyRepetition1;
    int        yyRepetition2;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    while (true) {

      final int yyChoice1 = yyRepetition1;

      // Nested alternative 1.

      yyC = character(yyChoice1);
      if (-1 != yyC) {
        yyIndex = yyChoice1 + 1;

        switch (yyC) {
        case ' ':
          {
            yyRepetition1 = yyIndex;
            continue;
          }

        case '\t':
          {
            yyRepetition1 = yyIndex;
            continue;
          }

        case '\f':
          {
            yyRepetition1 = yyIndex;
            continue;
          }

        case '\r':
          {
            final int yyChoice2 = yyIndex;

            // Nested alternative 1.

            yyC = character(yyChoice2);
            if ('\n' == yyC) {
              yyIndex = yyChoice2 + 1;

              yyRepetition1 = yyIndex;
              continue;
            }

            // Nested alternative 2.

            yyRepetition1 = yyChoice2;
            continue;
          }

        case '\n':
          {
            yyRepetition1 = yyIndex;
            continue;
          }

        case '/':
          {
            yyC = character(yyIndex);
            if (-1 != yyC) {
              yyIndex = yyIndex + 1;
              if ('/' == yyC) {

                yyRepetition2 = yyIndex;
                while (true) {

                  yyC = character(yyRepetition2);
                  if (-1 != yyC) {
                    yyIndex = yyRepetition2 + 1;

                    switch (yyC) {
                    case '\n':
                    case '\r':
                      /* No match. */
                      break;

                    default:
                      {
                        yyRepetition2 = yyIndex;
                        continue;
                      }
                    }
                  }
                  break;
                }

                yyResult = pEOL(yyRepetition2);
                yyError  = yyResult.select(yyError, yyRepetition1);
                if (yyResult.hasValue()) {

                  yyRepetition1 = yyResult.index;
                  continue;
                }
              }
            }
          }
          break;

        default:
          /* No match. */
        }
      }

      // Nested alternative 2.

      yyResult = pMLComment(yyChoice1);
      yyError  = yyResult.select(yyError, yyRepetition1);
      if (yyResult.hasValue()) {

        yyRepetition1 = yyResult.index;
        continue;
      }
      break;
    }

    yyValue = null;

    return new SemanticValue(yyValue, yyRepetition1, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal parser.Parser.MLComment.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pMLComment(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyPredIndex;
    boolean    yyPredMatched;
    int        yyBase;
    int        yyRepetition1;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('/' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('*' == yyC) {
        yyIndex = yyIndex + 1;

        yyRepetition1 = yyIndex;
        while (true) {

          final int yyChoice1 = yyRepetition1;

          // Nested alternative 1.

          yyResult = pMLComment(yyChoice1);
          yyError  = yyResult.select(yyError, yyRepetition1);
          if (yyResult.hasValue()) {

            yyRepetition1 = yyResult.index;
            continue;
          }

          // Nested alternative 2.

          yyPredMatched = false;

          yyC = character(yyChoice1);
          if ('*' == yyC) {
            yyPredIndex = yyChoice1 + 1;

            yyC = character(yyPredIndex);
            if ('/' == yyC) {

              yyPredMatched = true;
            }
          }

          if (! yyPredMatched) {

            yyC = character(yyChoice1);
            if (-1 != yyC) {
              yyIndex = yyChoice1 + 1;

              yyRepetition1 = yyIndex;
              continue;
            }
          } else {
            yyError = yyError.select("m l comment expected", yyStart);
          }
          break;
        }

        yyBase = yyRepetition1;
        yyC    = character(yyBase);
        if ('*' == yyC) {
          yyIndex = yyRepetition1 + 1;

          yyC = character(yyIndex);
          if ('/' == yyC) {
            yyIndex = yyIndex + 1;

            yyValue = null;

            return new SemanticValue(yyValue, yyIndex, yyError);
          } else {
            yyError = yyError.select("'*/' expected", yyBase);
          }
        } else {
          yyError = yyError.select("'*/' expected", yyBase);
        }
      }
    }

    // Done.
    yyError = yyError.select("m l comment expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal parser.Parser.EOL.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pEOL(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '\r':
        {
          final int yyChoice1 = yyIndex;

          // Nested alternative 1.

          yyC = character(yyChoice1);
          if ('\n' == yyC) {
            yyIndex = yyChoice1 + 1;

            yyValue = null;

            return new SemanticValue(yyValue, yyIndex, yyError);
          }

          // Nested alternative 2.

          yyValue = null;

          return new SemanticValue(yyValue, yyChoice1, yyError);
        }

      case '\n':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("EOL expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal parser.Parser.EOF.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pEOF(final int yyStart) throws IOException {
    int        yyC;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyPredMatched = false;

    yyC = character(yyStart);
    if (-1 != yyC) {

      yyPredMatched = true;
    }

    if (! yyPredMatched) {

      yyValue = null;

      return new SemanticValue(yyValue, yyStart, yyError);
    } else {
      yyError = yyError.select("EOF expected", yyStart);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  static {
    add (KEYWORDS, new String[] {
      "body", "defaultIndent", "defaultWidth", "header", "left", "line",
      "module", "nest", "nested", "none", "nospacing", "option", "paren",
      "rats", "relativeFilenames", "right", "setOfString", "sp", "String",
      "Token", "verbose", "Void"
    });
  }
  
  /** Set position of an Object using Kiama's Positions module */
  void setLocation(final Object object, final int start) {
    if (null != object) {
      Column s = column (start);
      Positions.setStart (object, new LineColPosition (this, start, s.line, s.column));
      int finish = yyCount == 0 ? 0 : yyCount - 1;
      Column f = column (finish);
      Positions.setFinish (object, new LineColPosition (this, finish, f.line, f.column));
    }
  }
  
  /** Apply a Scala list of actions */
  <T> T apply (List<Action<T>> actions, T seed) {
    while (! actions.isEmpty()) {
      seed    = actions.head().run(seed);
      actions = actions.drop(1);
    }
    return seed;
  }

  // =========================================================================

  /**
   * Add the specified values to the specified set.
   *
   * @param set The set.
   * @param values The new values.
   */
  protected static final <T> void add(Set<T> set, T[] values) {
    for (T v : values) set.add(v);
  }

  /**
   * Check whether the specified set contains the specified value.
   *
   * @param set The set.
   * @param value The value.
   * @return <code>true</code> if the set contains the value.
   */
  protected static final <T> boolean contains(Set<T> set, T value) {
    return set.contains(value);
  }

}
